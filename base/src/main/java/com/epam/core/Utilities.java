package com.epam.core;

import com.epam.core.properties.EnvironmentConfiguration;
import org.aeonbits.owner.ConfigFactory;
import org.apache.commons.io.FilenameUtils;
import org.apache.commons.io.IOUtils;
import org.apache.commons.lang3.RandomStringUtils;
import org.apache.commons.lang3.text.WordUtils;

import java.io.File;
import java.io.FileOutputStream;
import java.io.InputStream;
import java.io.OutputStream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Date;
import java.util.TimeZone;


/**
 * Generic Utility static methods that are application/project independent
 */
public class Utilities {
    private static final EnvironmentConfiguration propertiesManager = ConfigFactory.create(EnvironmentConfiguration.class);

    /**
     * Returns an instance of the current date (minus a few minutes to account for server time differences).
     *
     * @return
     */
    public static Date getCurrentDate() {
        return moveDate(new Date(), Calendar.MINUTE, -5);
    }

    /**
     * Moves the specified date forward (or backward) by the specified amount.
     *
     * @param date
     * @param calendarField
     * @param amount
     * @return
     */
    public static Date moveDate(Date date, int calendarField, int amount) {
        Calendar calendar = Calendar.getInstance();
        calendar.setTime(date);
        calendar.add(calendarField, amount);

        return calendar.getTime();
    }

    /**
     * Returns the specified date formatted into a date display converted for presentation in the application server's
     * timezone.
     *
     * @param date
     * @return
     */
    public static String formatAsDate(Date date) {
        return formatDate(date, "MM-dd-yyyy hh:mm aa");
    }

    /**
     * Returns the specified date formatted into a datetime display converted for presentation in the application
     * server's timezone.
     *
     * @param date
     * @return
     */
    public static String formatAsDateTime(Date date) {
        return formatDate(date, "MM-dd-yyyy hh:mm aa");
    }

    /**
     * Returns the specified time formatted into a time display converted for presentation in the application server's
     * timezone.
     *
     * @param date
     * @return
     */
    public static String formatAsTime(Date date) {
        return formatDate(date,"hh:mm aa");
    }

    /**
     * Internal method use to format a {@link Date} object into the specified {@link String} pattern.
     *
     * @param date
     * @param pattern
     * @return
     */
    private static String formatDate(Date date, String pattern) {
        TimeZone timeZone = TimeZone.getTimeZone("CST");
        SimpleDateFormat simpleDateFormat = new SimpleDateFormat(pattern);
        simpleDateFormat.setTimeZone(timeZone);
        return simpleDateFormat.format(date);
    }

    /**
     * Attempts to parse the specified string into a {@link Date} object. This method will attempt parsing various
     * different patterns, starting with the most specific and moving to the most general.
     *
     * @param date
     * @return
     */
    public static Date parseDate(String date) {
        Date result = null;
        TimeZone timeZone = TimeZone.getTimeZone("CST");
        String[] patternProperties = { "MM-dd-yyyy", "MM-dd-yyyy" };

        for (int i = 0; i < patternProperties.length; i++) {
            SimpleDateFormat simpleDateFormat = new SimpleDateFormat((patternProperties[i]));
            simpleDateFormat.setTimeZone(timeZone);

            try {
                result = simpleDateFormat.parse(date);
                break;
            } catch (ParseException e) {
                // OK, do nothing
            }
        }

        if (result == null) {
            throw new RuntimeException("Unable to parse date from: " + date);
        }

        return result;
    }

    /**
     * Returns a unique number that is generated by the current time stamp in HHmmss format
     *
     * @return
     */
    public static String getUniqueNumber() {
        return String.valueOf(new Date().getTime()).substring(4);
    }

    /**
     * Returns the first non-null value from the list of arguments. If all arguments are null, null will be returned.
     *
     * @param strings
     * @return
     */
    public static String firstNonNull(String... strings) {
        String result = null;
        if (strings != null) {
            for (String s : strings) {
                if (s != null) {
                    result = s;
                    break;
                }
            }
        }

        return result;
    }

    /**
     * Accepts a resource location (from the sampleFiles folder) and copies that resource to a temporary location.
     * Returns the canonical path of the file created. Note that this temp file is flagged for deletion upon termination
     * of the JVM -- no manual deletions are necessary.
     * <p>
     * Usage example:
     * <p>
     * FileElement fileElement = ...;<br/> String path = Utilities.createTempFile("/sampleFiles/sample.pdf");<br/>
     * fileElement.setPath(path);
     *
     * @param resource
     * @return
     */
    public static String createTempFile(String resource) {
        File tempFile = null;
        InputStream in = null;
        OutputStream out = null;

        try {
            String suffix = "." + FilenameUtils.getExtension(resource);
            tempFile = File.createTempFile(RandomStringUtils.randomAlphanumeric(16), suffix);

            out = new FileOutputStream(tempFile);
            in = Utilities.class.getResourceAsStream(resource);

            IOUtils.copy(in, out);
            out.flush();

            return tempFile.getCanonicalPath();
        } catch (Exception exc) {
            throw new RuntimeException("error creating temp file", exc);
        } finally {
            IOUtils.closeQuietly(in);
            IOUtils.closeQuietly(out);
            if (tempFile != null) {
                tempFile.deleteOnExit();
            }
        }
    }

    /**
     * Returns the specified name string formatted into "LastName, FirstName MiddleName" format
     *
     * @param fullName
     * @return
     */
    public static String formatFullName(String fullName) {
        if (fullName == null) {
            return fullName;
        }

        String[] tempNameArray = fullName.split("\\s+");
        if (tempNameArray.length == 1) {
            return tempNameArray[0];
        } else if (tempNameArray.length > 2) {
            return tempNameArray[2] + ", " + tempNameArray[0] + " " + tempNameArray[1];
        } else {
            return tempNameArray[1] + ", " + tempNameArray[0];
        }
    }

    /**
     * Returns the capitalized name
     * <p>
     * Here is the example:
     * <p>
     * input = add new charge; output = Add New Charge;
     *
     * @param message - message to capitalize
     * @return capitalized name
     */
    public static String capitalize(String message) {
        return WordUtils.capitalize(message);
    }

    /**
     * Returns random name
     *
     * @param length - random name length
     * @return random name
     */
    public static String getRandomName(int length) {
        return RandomStringUtils.randomAlphanumeric(length);
    }

    /**
     * Return file name with extension from file path
     *
     * @param filePath - path to file
     * @return
     */
    public static String getFileNameFromPath(String filePath) {
        Path p = Paths.get(filePath);
        return p.getFileName().toString();
    }

    /**
     * Generate string of domain type. Example: abcd.com
     *
     * @return
     */
    public static String generateDomainAdress() {
        return (RandomStringUtils.randomAlphabetic(4) + ".com").toLowerCase();
    }
}
